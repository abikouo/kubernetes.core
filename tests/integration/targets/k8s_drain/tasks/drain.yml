---
# Drain the node (Should failed)
- name: Drain node with expected failure (check_mode=true)
  k8s_drain:
    state: drain
    name: '{{ node_to_drain }}'
  ignore_errors: true
  register: drain_failed_check_mode
  check_mode: true

- name: Assert that drain failed due to DaemonSet managed Pods
  assert:
    that:
    - drain_failed_check_mode is failed
    - '"cannot delete DaemonSet-managed Pods" in drain_failed_check_mode.msg'
    - '"cannot delete Pods not managed by ReplicationController, ReplicaSet, Job, DaemonSet or StatefulSet" in drain_failed_check_mode.msg'
    - '"cannot delete Pods with local storage" in drain_failed_check_mode.msg'

- name: Ensure that the node remains schedulable
  ansible.builtin.include_tasks: tasks/validate_node_status.yml
  vars:
    schedulable: true

- name: Drain node with expected failure
  k8s_drain:
    state: drain
    name: '{{ node_to_drain }}'
  ignore_errors: true
  register: drain_failed

- name: Assert that drain failed due to DaemonSet managed Pods
  assert:
    that:
    - drain_failed is failed
    - '"cannot delete DaemonSet-managed Pods" in drain_failed.msg'
    - '"cannot delete Pods not managed by ReplicationController, ReplicaSet, Job, DaemonSet or StatefulSet" in drain_failed.msg'
    - '"cannot delete Pods with local storage" in drain_failed.msg'

- name: Ensure that the node remains schedulable
  ansible.builtin.include_tasks: tasks/validate_node_status.yml
  vars:
    schedulable: true

# Drain the node ignoring non-candidate Pods
# check_mode
- name: Drain node using ignore_daemonsets, force, and delete_emptydir_data options (check_mode=true)
  k8s_drain:
    state: drain
    name: '{{ node_to_drain }}'
    delete_options:
      force: true
      ignore_daemonsets: true
      delete_emptydir_data: true
      wait_timeout: 0
  register: drain_force_check_mode
  check_mode: true

- name: Assert that module reported changed while node was not drained
  assert:
    that:
    - drain_force_check_mode is changed
    - '"node "+node_to_drain+" marked unschedulable." in drain_force_check_mode.result'

- name: Ensure node remains schedulable
  ansible.builtin.include_tasks: tasks/validate_node_status.yml
  vars:
    schedulable: true

- name: Assert that running with check_mode did not deleted any Pod
  k8s_info:
    namespace: '{{ test_namespace }}'
    kind: Pod
    label_selectors:
      - "{{ item }}"
  register: pods
  failed_when: pods.resources | length == 0
  loop:
    - drain=unmanaged-pod
    - drain=daemonset-pod
    - drain=emptyDir

# Apply
- name: Drain node using ignore_daemonsets, force, and delete_emptydir_data options
  k8s_drain:
    state: drain
    name: '{{ node_to_drain }}'
    delete_options:
      force: true
      ignore_daemonsets: true
      delete_emptydir_data: true
      wait_timeout: 0
  register: drain_force

- name: Assert that module reported changed
  assert:
    that:
    - drain_force is changed
    - '"node "+node_to_drain+" marked unschedulable." in drain_force.result'

- name: Ensure node is now unschedulable
  ansible.builtin.include_tasks: tasks/validate_node_status.yml

- name: Assert that unmanaged Pod were deleted
  k8s_info:
    namespace: '{{ test_namespace }}'
    kind: Pod
    label_selectors:
      - drain=unmanaged-pod
  register: pods
  failed_when: pods.resources | length > 0

- name: Assert that Pod with local storage are not Pending
  k8s_info:
    namespace: '{{ test_namespace }}'
    kind: Pod
    label_selectors:
      - drain=emptyDir
  register: pods
  failed_when: pods.resources | map(attribute='status.phase') | unique != ['Pending']

- name: Assert that DaemonSet-managed pod were not deleted
  k8s_info:
    namespace: '{{ test_namespace }}'
    kind: Pod
    label_selectors:
      - drain=daemonset-pod
  register: pods
  failed_when: pods.resources | length == 0

# Idempotency
- name: Test drain idempotency (check_mode=true)
  k8s_drain:
    state: drain
    name: '{{ node_to_drain }}'
    delete_options:
      force: true
      ignore_daemonsets: true
      delete_emptydir_data: true
  register: drain_force_idempotency_check_mode
  check_mode: true

- name: Validate idempotency with check_mode
  assert:
    that:
    - drain_force_idempotency_check_mode is not changed

- name: Ensure node remains unschedulable
  ansible.builtin.include_tasks: tasks/validate_node_status.yml

- name: Assert that DaemonSet-managed pod were not deleted
  k8s_info:
    namespace: '{{ test_namespace }}'
    kind: Pod
    label_selectors:
      - drain=daemonset-pod
  register: pods
  failed_when: pods.resources | length == 0

# Drain with disable_eviction = true
# check_mode
- name: Uncordon node
  k8s_drain:
    state: uncordon
    name: '{{ node_to_drain }}'

- name: Create once again the Pod deleted before
  k8s:
    namespace: '{{ test_namespace }}'
    wait: true
    wait_timeout: "{{ k8s_wait_timeout | default(omit) }}"
    template: pod1.yml.j2

- name: Drain node using disable_eviction (check_mode)
  k8s_drain:
    state: drain
    name: '{{ node_to_drain }}'
    delete_options:
      force: true
      disable_eviction: true
      terminate_grace_period: 0
      ignore_daemonsets: true
      wait_timeout: 0
      delete_emptydir_data: true
  register: disable_evict_check_mode
  check_mode: true

- name: Assert that node has been drained
  assert:
    that:
    - disable_evict_check_mode is changed
    - '"node "+node_to_drain+" marked unschedulable." in disable_evict_check_mode.result'

- name: Ensure node remains schedulable (check_mode)
  ansible.builtin.include_tasks: tasks/validate_node_status.yml
  vars:
    schedulable: true

- name: Assert that unmanaged Pod were not deleted
  k8s_info:
    namespace: '{{ test_namespace }}'
    kind: Pod
    label_selectors:
      - drain=unmanaged-pod
  register: pods
  failed_when: pods.resources | length == 0

# apply
- name: Drain node using disable_eviction
  k8s_drain:
    state: drain
    name: '{{ node_to_drain }}'
    delete_options:
      force: true
      disable_eviction: true
      terminate_grace_period: 0
      ignore_daemonsets: true
      wait_timeout: 0
      delete_emptydir_data: true
  register: disable_evict

- name: Assert that node has been drained
  assert:
    that:
    - disable_evict is changed
    - '"node "+node_to_drain+" marked unschedulable." in disable_evict_check_mode.result'

- name: Ensure the node is unschedulable
  ansible.builtin.include_tasks: tasks/validate_node_status.yml

# Drain using pod_selectors
- name: Uncordon node
  k8s_drain:
    state: uncordon
    name: '{{ node_to_drain }}'

- name: Create Pod with label selector
  k8s:
    namespace: "{{ test_namespace }}"
    wait: true
    template: pod1.yml.j2

# check_mode
- name: Drain the node using pod_selectors matching no Pod
  k8s_drain:
    state: drain
    name: '{{ node_to_drain }}'
    pod_selectors:
    - drain=no_match_selector
    delete_options:
      terminate_grace_period: 0
      delete_emptydir_data: true
      force: true
      ignore_daemonsets: true
  register: drain_pod_selector_no_match_check_mode
  check_mode: true

- name: Assert that module reported change while running in check_mode
  assert:
    that:
    - drain_pod_selector_no_match_check_mode is changed
    - '"node "+node_to_drain+" marked unschedulable." in drain_pod_selector_no_match_check_mode.result'

- name: Ensure that the node remains schedulable
  ansible.builtin.include_tasks: tasks/validate_node_status.yml
  vars:
    schedulable: true

- name: Validate that Pod are still running
  k8s_info:
    namespace: '{{ test_namespace }}'
    kind: Pod
    label_selectors:
      - drain=unmanaged-pod
    field_selectors:
      - status.phase=Running
  register: pods
  failed_when: pods.resources | length == 0

# apply
- name: Drain the node using pod_selectors matching no Pod
  k8s_drain:
    state: drain
    name: '{{ node_to_drain }}'
    pod_selectors:
    - drain=no_match_selector
    delete_options:
      terminate_grace_period: 0
      delete_emptydir_data: true
      force: true
      ignore_daemonsets: true
  register: drain_pod_selector_no_match

- name: Assert that node has been drained
  assert:
    that:
    - drain_pod_selector_no_match is changed
    - '"node "+node_to_drain+" marked unschedulable." in drain_pod_selector_no_match.result'

- name: Ensure the node is unschedulable
  ansible.builtin.include_tasks: tasks/validate_node_status.yml

- name: Validate that Pod are still running
  k8s_info:
    namespace: '{{ test_namespace }}'
    kind: Pod
    label_selectors:
      - drain=unmanaged-pod
    field_selectors:
      - status.phase=Running
  register: pods
  failed_when: pods.resources | length == 0

# Drain the node using matching pod_selector
- name: Uncordon node
  k8s_drain:
    state: uncordon
    name: '{{ node_to_drain }}'

# check_mode
- name: Drain the node using matching pod_selectors
  k8s_drain:
    state: drain
    name: '{{ node_to_drain }}'
    pod_selectors:
    - drain=unmanaged-pod
    delete_options:
      terminate_grace_period: 0
      delete_emptydir_data: true
      force: true
      ignore_daemonsets: true
  register: drain_pod_selector_match_check_mode
  check_mode: true

- name: Assert that module reported change while running in check_mode
  assert:
    that:
    - drain_pod_selector_match_check_mode is changed
    - '"node "+node_to_drain+" marked unschedulable." in drain_pod_selector_match_check_mode.result'

- name: Ensure that the node remains schedulable
  ansible.builtin.include_tasks: tasks/validate_node_status.yml
  vars:
    schedulable: true

- name: Validate that Pod are still running
  k8s_info:
    namespace: '{{ test_namespace }}'
    kind: Pod
    label_selectors:
      - drain=unmanaged-pod
    field_selectors:
      - status.phase=Running
  register: pods
  failed_when: pods.resources | length == 0

# apply
- name: Drain the node using matching pod_selectors
  k8s_drain:
    state: drain
    name: '{{ node_to_drain }}'
    pod_selectors:
    - drain=unmanaged-pod
    delete_options:
      terminate_grace_period: 0
      delete_emptydir_data: true
      force: true
      ignore_daemonsets: true
      wait_timeout: 0
  register: drain_pod_selector_match

- name: Assert that node has been drained
  assert:
    that:
    - drain_pod_selector_match is changed
    - '"node "+node_to_drain+" marked unschedulable." in drain_pod_selector_match.result'

- name: Ensure the node is unschedulable
  ansible.builtin.include_tasks: tasks/validate_node_status.yml

- name: Validate that Pod are not running
  k8s_info:
    namespace: '{{ test_namespace }}'
    kind: Pod
    label_selectors:
      - drain=unmanaged-pod
    field_selectors:
      - status.phase=Running
  register: pods
  failed_when: pods.resources | length > 0
